<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EXTREME IMMERSIVE LAB</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#fff;overflow-x:hidden;font-family:system-ui}
canvas{position:fixed;inset:0}
.scroll{height:1200vh}
.overlay{
 position:fixed;inset:0;
 display:flex;align-items:center;justify-content:center;
 pointer-events:none;text-align:center;padding:10vw
}
.overlay h1{font-size:clamp(2.5rem,6vw,5rem)}
.overlay p{opacity:.7;margin-top:20px;max-width:600px}
</style>
</head>
<body>

<div class="scroll"></div>

<div class="overlay">
  <div>
    <h1>EXTREME LAB</h1>
    <p>Raymarching • Partículas • Morphing • WebGPU</p>
  </div>
</div>

<canvas id="gfx"></canvas>

<script type="module">

/* =========================================================
   SCROLL PHYSICS
========================================================= */

let target=0,current=0
const maxScroll=document.body.scrollHeight-innerHeight

addEventListener("scroll",()=>{
 target=scrollY/maxScroll
})

function updateScroll(){
 current+=(target-current)*0.07
}

/* =========================================================
   WEBGPU DETECTION
========================================================= */

const canvas=document.getElementById("gfx")

let useWebGPU=false

if(navigator.gpu){
 try{
  await navigator.gpu.requestAdapter()
  useWebGPU=true
 }catch(e){}
}

/* =========================================================
   IF WEBGPU AVAILABLE
========================================================= */

if(useWebGPU){

 const adapter=await navigator.gpu.requestAdapter()
 const device=await adapter.requestDevice()
 const context=canvas.getContext("webgpu")
 const format=navigator.gpu.getPreferredCanvasFormat()

 context.configure({
  device,
  format,
  alphaMode:"premultiplied"
 })

 const shader=`
 @vertex
 fn vs(@builtin(vertex_index) i:u32)->@builtin(position) vec4<f32>{
  var pos=array<vec2<f32>,6>(
   vec2(-1,-1),vec2(1,-1),vec2(-1,1),
   vec2(-1,1),vec2(1,-1),vec2(1,1)
  );
  return vec4(pos[i],0,1);
 }

 @fragment
 fn fs(@builtin(position) p:vec4<f32>)->@location(0) vec4<f32>{
  let uv=p.xy/vec2<f32>(${innerWidth}.0,${innerHeight}.0);
  let c=0.5+0.5*sin(uv.x*20.0);
  return vec4(c*uv.x,uv.y,c,1.0);
 }
 `

 const module=device.createShaderModule({code:shader})
 const pipeline=device.createRenderPipeline({
  layout:"auto",
  vertex:{module,entryPoint:"vs"},
  fragment:{module,entryPoint:"fs",targets:[{format}]},
  primitive:{topology:"triangle-list"}
 })

 function frame(){
  updateScroll()
  const encoder=device.createCommandEncoder()
  const view=context.getCurrentTexture().createView()
  const pass=encoder.beginRenderPass({
   colorAttachments:[{
    view,
    loadOp:"clear",
    storeOp:"store",
    clearValue:{r:0,g:0,b:0,a:1}
   }]
  })
  pass.setPipeline(pipeline)
  pass.draw(6)
  pass.end()
  device.queue.submit([encoder.finish()])
  requestAnimationFrame(frame)
 }

 frame()

}else{

/* =========================================================
   WEBGL2 PIPELINE
========================================================= */

import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152/build/three.module.js"

const renderer=new THREE.WebGLRenderer({canvas,antialias:true})
renderer.setSize(innerWidth,innerHeight)
renderer.setPixelRatio(Math.min(2,devicePixelRatio))

const scene=new THREE.Scene()
const camera=new THREE.PerspectiveCamera(65,innerWidth/innerHeight,.1,100)
camera.position.z=6

/* ======================
   MORPHING GEOMETRY
====================== */

const geo=new THREE.IcosahedronGeometry(2,64)
const mat=new THREE.MeshStandardMaterial({
 color:0x8888ff,
 metalness:.3,
 roughness:.2
})

const mesh=new THREE.Mesh(geo,mat)
scene.add(mesh)

/* ======================
   PARTICLE SYSTEM
====================== */

const pGeo=new THREE.BufferGeometry()
const count=2000
const positions=new Float32Array(count*3)

for(let i=0;i<count;i++){
 positions[i*3]=(Math.random()-0.5)*20
 positions[i*3+1]=(Math.random()-0.5)*20
 positions[i*3+2]=(Math.random()-0.5)*20
}

pGeo.setAttribute("position",new THREE.BufferAttribute(positions,3))

const pMat=new THREE.PointsMaterial({
 size:.05,
 color:0xffffff
})

const particles=new THREE.Points(pGeo,pMat)
scene.add(particles)

/* ======================
   RAYMARCH SHADER PLANE
====================== */

const rmGeo=new THREE.PlaneGeometry(30,30)
const rmMat=new THREE.ShaderMaterial({
 uniforms:{
  u_time:{value:0},
  u_progress:{value:0}
 },
 vertexShader:`
  varying vec2 vUv;
  void main(){
   vUv=uv;
   gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
  }
 `,
 fragmentShader:`
  uniform float u_time;
  uniform float u_progress;
  varying vec2 vUv;

  float sphere(vec3 p,float r){
   return length(p)-r;
  }

  void main(){
   vec2 uv=vUv*2.-1.;
   vec3 ro=vec3(0.,0.,5.);
   vec3 rd=normalize(vec3(uv,-1.));
   float t=0.;
   float d;
   for(int i=0;i<64;i++){
    vec3 p=ro+rd*t;
    d=sphere(p,1.+u_progress);
    if(d<0.001) break;
    t+=d;
   }
   float shade=exp(-t*0.2);
   gl_FragColor=vec4(vec3(shade),0.4);
  }
 `,
 transparent:true
})

const rmMesh=new THREE.Mesh(rmGeo,rmMat)
rmMesh.position.z=-10
scene.add(rmMesh)

/* ======================
   LIGHT
====================== */

const light=new THREE.PointLight(0xffffff,2)
light.position.set(3,3,3)
scene.add(light)

/* ======================
   ANIMATION LOOP
====================== */

function animate(){
 requestAnimationFrame(animate)

 updateScroll()

 mesh.rotation.x+=0.01
 mesh.rotation.y+=0.008

 // Morph effect
 mesh.scale.setScalar(1+current*2)

 particles.rotation.y+=0.002

 rmMat.uniforms.u_time.value+=0.02
 rmMat.uniforms.u_progress.value=current

 camera.position.z=6+current*10

 renderer.render(scene,camera)
}

animate()

addEventListener("resize",()=>{
 renderer.setSize(innerWidth,innerHeight)
 camera.aspect=innerWidth/innerHeight
 camera.updateProjectionMatrix()
})

}

</script>
</body>
</html>